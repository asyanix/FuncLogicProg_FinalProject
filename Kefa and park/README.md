## Задача 580C "Кефа и парк"

Ознакомиться с задачей подробнее можно [здесь](https://codeforces.com/problemset/problem/580/C).

Решение на C# [здесь](/Kefa%20and%20park/KefaCSharp/Program.cs).

Решение на F# [здесь](/Kefa%20and%20park/KefaFSharp/Program.fs).

---

## Описание

Кефа решил отпраздновать свой первый крупный заработок походом в ресторан.

Он живет возле необычного парка. Парк представляет из себя подвешенное дерево из n вершин c корнем в вершине 1. В вершине 1 также находится дом Кефы. К сожалению для нашего героя, в парке также находятся коты **☹**. Кефа уже выяснил номера вершин, в которых находятся коты.

В листовых вершинах парка находятся рестораны. Кефа хочет выбрать ресторан, в который он пойдет, но, к сожалению, он очень боится котов, поэтому он ни за что не пойдёт в ресторан, на пути к которому от его дома найдётся более m подряд идущих вершин с котами.

Ваша задача – помочь Кефе посчитать количество ресторанов, в которые он может сходить.

#### Входные данные

В первой строке записаны два целых числа n и m (2 ≤ n ≤ 105, 1 ≤ m ≤ n) – количество вершин дерева и максимальное количество подряд идущих вершин с котами, которое способен перенести Кефа.

Во второй строке содержится n целых чисел a1, a2, ..., an, где каждое ai либо равняется 0 (тогда в вершине i нет кота), либо равняется 1 (тогда в вершине i есть кот).

В следующих n - 1 строках записаны ребра дерева в формате «xi yi»(без кавычек) (1 ≤ xi, yi ≤ n, xi ≠ yi), где xi и yi – вершины дерева, соединенные очередным ребром.

Гарантируется, что данный набор рёбер задаёт дерево.

#### Выходные данные

Одно целое число – количество различных листьев дерева, на пути от дома Кефы до которых не больше m подряд идущих вершин с котами.

---

## Решение задачи

Есть парк, который представляет собой **дерево с корнем в вершине 1** – это дом Кефы. Вершины дерева могут содержать **котов**, и Кефа их боится. Он хочет добраться от своего дома до **ресторанов**, которые находятся в **листовых вершинах** (то есть в вершинах, у которых нет дочерних вершин).

![Image](/Kefa%20and%20park/img/Pasted%20image%2020250525151053.png)

В задаче известно следующее:

- **Число вершин** `n` – всего сколько узлов в дереве.
- **Число `m`** – максимально допустимое количество подряд идущих вершин с котами, которое может выдержать Кефа.
- Для каждой вершины – указано, **есть ли в ней кот** (1 – есть, 0 – нет).
- Затем идут **`n - 1` ребро**, каждое соединяет две вершины дерева. Это дерево, то есть все вершины соединены и нет циклов.

Для каждой вершины мы храним, с какими другими она соединена, используя списки смежности. **Список смежности** – это способ представления графа в виде массива списков, где каждый элемент массива соответствует вершине графа и содержит список всех смежных с ней вершин.

Обход начинается с корня (вершины 1).

Идём по дереву, переходя к каждой соседней вершине кроме той, откуда пришли, и на каждом шаге отслеживаем:
- находится ли в текущей вершине кот;
- сколько подряд было вершин с котами (если встречается вершина без кота – счётчик сбрасывается).

Если в какой-то момент число подряд идущих вершин с котами превышает допустимое значение `m`, путь дальше не рассматривается.

Если текущая вершина – **лист**, то есть больше никуда не ведёт, и при этом условие по котам не нарушено – значит, Кефа может дойти до ресторана в этой вершине, поэтому увеличиваем общий счётчик подходящих ресторанов.

---

## Описание решения задачи на C#

[Программа](/Kefa%20and%20park/KefaCSharp/Program.cs) решает задачу с использованием поиска в глубину по дереву. Сначала она считывает два числа – общее количество вершин (`n`) и максимально допустимое количество подряд идущих вершин с котами (`m`). Далее в массив (`cats`) загружается информация о том, есть ли кот в каждой вершине: единица означает наличие кота, ноль – отсутствие.

После этого строится дерево. Для этого используется массив списков (`g`), где каждый элемент – это список смежных вершин, то есть те вершины, которые напрямую соединены с текущей. Например, если считано ребро (`a`, `b`), то обе вершины добавляются друг к другу в списки смежности (`g[a].Add(b)` и `g[b].Add(a)`).

Основная логика реализована в функции `DFS`, которая рекурсивно обходит дерево в глубину начиная с вершины 1 – дома Кефы. В неё передаются текущая вершина (`v`), предыдущая (`prev`) и текущее количество подряд идущих вершин с котами (`cnt`). Если на каком-то этапе количество таких котов превышает `m` (условие `if (cnt > m)`), поиск по этому пути прекращается.

Когда встречается листовая вершина (то есть вершина, у которой только один сосед и она не является корнем, проверяется условием `g[v].Count == 1 && v != 1`), и при этом путь до неё удовлетворяет условиям, она считается подходящим рестораном, и счётчик допустимых маршрутов увеличивается.

При обходе всех смежных вершин (в цикле `foreach (int to in g[v])`), происходит проверка: если вершина ещё не посещалась (то есть не является родительской, `to != prev`), то выполняется переход и новый вызов `DFS`. При этом обновляется счётчик котов: если в новой вершине кота нет, он обнуляется (`c = 0`), иначе увеличивается на единицу (`c = cnt + 1`).

Стартовый вызов функции – это `DFS(1, -1, cats[1])`, так как начинаем с вершины 1, у неё нет родителя (поэтому `-1`), и учитываем, есть ли в ней кот сразу.

## Описание решения задачи на F#

Решение задачи [на F#](/Kefa%20and%20park/KefaFSharp/Program.fs) устроено по тому же принципу, что и на C#. Сначала считываются два числа – общее количество вершин (`n`) и максимально допустимое число подряд идущих вершин с котами (`m`). Далее считывается список, где указано, есть ли кот в каждой вершине. Этот список хранится в переменной (`cats`), в которой каждый элемент – это 0 или 1, соответственно, нет или есть кот.

Следующим этапом считываются рёбра дерева, то есть пары вершин, соединённые друг с другом. Это делается с помощью рекурсивной функции (`readEdges`), которая поочерёдно добавляет все считанные пары в список. После этого из этих пар строится представление дерева в виде списков смежности. Для этого создаётся пустая структура (`empty`), представляющая собой список списков, а затем каждый элемент обновляется функцией (`List.fold`), которая добавляет соседей друг к другу. В итоге в переменной (`g`) оказывается список, где каждый элемент по индексу `i` содержит список всех вершин, соединённых с `i`.

Далее вызывается функция (`dfs`), которая реализует поиск в глубину. Она принимает структуру дерева (`g`), список котов (`cats`), ограничение по котам (`m`), текущую вершину (`v`), предыдущую вершину (`prev`) и текущее количество подряд идущих вершин с котами (`cnt`). Если число подряд идущих котов превышает `m`, то функция сразу возвращает 0 – дальнейший путь не рассматривается. Если текущая вершина – лист (проверяется условием `List.length (List.item v g) = 1 && v <> 1`), и при этом путь до неё допустим, она засчитывается как подходящий ресторан, и функция возвращает 1.

Во всех остальных случаях происходит рекурсивный вызов этой же функции для всех соседей текущей вершины, кроме той, откуда мы пришли (это проверяется условием `toV <> prev`). Для каждой следующей вершины пересчитывается счётчик котов: если кота нет (`catVal = 0`), то он сбрасывается в 0, иначе увеличивается на единицу (`cnt + 1`). Сумма всех возвращённых значений от таких рекурсивных вызовов и будет итоговым количеством подходящих ресторанов.

Начальный вызов функции (`dfs`) происходит из вершины 1, то есть от дома Кефы. Предыдущей вершины у неё нет, поэтому туда передаётся `-1`. Начальное значение счётчика котов (`startCnt`) определяется по тому, есть ли кот в первой вершине (проверяется через `if List.head cats = 1 then 1 else 0`). 

---

## Тест-кейсы


### Тест-кейс 1: Минимальный случай

Входные данные: 
```
2 1
0 1
1 2
```

**Ожидаемый результат:**

Выходные данные:
```
1
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы | Время работы     | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `1`       |     0.002 сек    |        0.02 МБ        |
|   F#     |        `1`       |     0.038 сек    |        0.041 МБ       |

Результат тестирования: **ПРОЙДЕНО**.

##
### Тест-кейс 2: Стандартный случай

Входные данные: 
```
4 1
1 1 0 0
1 2
1 3
1 4
```

**Ожидаемый результат:**

Выходные данные:
```
2
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `2`       |     0.002 сек    |        0.02 МБ        |
|   F#     |        `2`       |     0.036 сек    |        0.042 МБ       |

Результат тестирования: **ПРОЙДЕНО**.

##
### Тест-кейс 3: Линейное дерево, все коты

Входные данные: 
```
5 2
1 1 1 1 1
1 2
2 3
3 4
4 5
```

**Ожидаемый результат:**

Выходные данные:
```
0
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `0`       |     0.002 сек    |        0.01 МБ        |
|   F#     |        `0`       |     0.037 сек    |        0.042 МБ       |

Результат тестирования: **ПРОЙДЕНО**.


##
### Тест-кейс 4: Один кот в корне, все дети без котов

Входные данные: 
```
5 1
1 0 0 0 0
1 2
1 3
1 4
1 5
```

**Ожидаемый результат:**

Выходные данные:
```
4
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `2`       |     0.002 сек    |        0.01 МБ        |
|   F#     |        `2`       |     0.032 сек    |        0.043 МБ       |

Результат тестирования: **ПРОЙДЕНО**.

##
### Тест-кейс 5: Массив котов в одной ветке

Входные данные: 
```
7 2
0 1 1 1 0 0 0
1 2
2 3
3 4
1 5
5 6
6 7
```

**Ожидаемый результат:**

Выходные данные:
```
1
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `1`       |     0.002 сек    |        0.02 МБ        |
|   F#     |        `1`       |     0.035 сек    |        0.044 МБ       |

Результат тестирования: **ПРОЙДЕНО**.

##
### Тест-кейс 6: Один большой блок котов на одной ветви

Входные данные: 
```
9 3
0 1 1 1 1 0 0 0 0
1 2
2 3
3 4
4 5
1 6
6 7
7 8
8 9
```

**Ожидаемый результат:**

Выходные данные:
```
1
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `1`       |     0.011 сек    |        0.02 МБ        |
|   F#     |        `1`       |     0.024 сек    |        0.045 МБ       |

Результат тестирования: **ПРОЙДЕНО**.

##
### Тест-кейс 7: Среднее дерево с разными ветвями

Входные данные: 
```
9 2
0 1 1 0 0 1 0 0 1
1 2
1 3
2 4
2 5
3 6
3 7
5 8
5 9
```

**Ожидаемый результат:**

Выходные данные:
```
5
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `5`       |     0.002 сек    |        0.11 МБ        |
|   F#     |        `5`       |     0.026 сек    |        0.045 МБ       |

Результат тестирования: **ПРОЙДЕНО**.

##
### Тест-кейс 8: Несколько длинных веток, коты в начале

Входные данные: 
```
7 2
1 1 0 0 0 0 0
1 2
2 3
2 4
1 5
5 6
5 7
```

**Ожидаемый результат:**

Выходные данные:
```
4
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `4`       |     0.002 сек    |        0.02 МБ        |
|   F#     |        `4`       |     0.037 сек    |        0.044 МБ       |

Результат тестирования: **ПРОЙДЕНО**.


##
### Тест-кейс 9: Компактное дерево

Входные данные: 
```
6 1
1 0 1 0 0 1
1 2
1 3
2 4
2 5
3 6
```

**Ожидаемый результат:**

Выходные данные:
```
2
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `2`       |     0.002 сек    |        0.11 МБ        |
|   F#     |        `2`       |     0.032 сек    |        0.043 МБ       |

Результат тестирования: **ПРОЙДЕНО**.


##
### Тест-кейс 10: 20 вершин и 2 кота

Входные данные: 
```
20 2
0 1 0 0 1 0 0 1 0 0  1 0 0 0 1 1 0 0 1 0
1 2
1 3
2 4
2 5
3 6
3 7
4 8
4 9
5 10
5 11
6 12
6 13
7 14
7 15
10 16
10 17
11 18
11 19
12 20
```

**Ожидаемый результат:**

Выходные данные:
```
8
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `2`       |     0.002 сек    |        0.11 МБ        |
|   F#     |        `2`       |     0.037 сек    |        0.058 МБ       |

Результат тестирования: **ПРОЙДЕНО**.

### Все тест-кейсы успнешно пройдены.