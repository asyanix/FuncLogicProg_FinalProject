## Задача 115A "Праздник"

Ознакомиться с задачей подробнее можно [здесь](https://codeforces.com/problemset/problem/115/A).

Решение на C# [здесь](/Holiday/HolidayCSharp/Program.cs).

Решение на F# [здесь](Holiday/HolidayFSharp/Program.cs).

Решение на Prolog [здесь](/Holiday/HolidayProlog/Holiday.pl).

---

## Описание

В компании работает _n_ сотрудников, пронумерованных от 1 до _n_. У каждого сотрудника либо нет руководителя, либо есть ровно один непосредственный руководитель – некоторый другой сотрудник с другим номером. Сотрудник _A_ называется начальником другого сотрудника _B_, если выполняется хотя бы одно из двух условий:

- Сотрудник _A_ – непосредственный руководитель сотрудника _B_.
- У сотрудника _B_ есть непосредственный руководитель, сотрудник _C_, такой, что _A_ является начальником сотрудника _C_.

В структуре компании нет циклов. То есть никакой сотрудник не является начальником своего непосредственного руководителя.

Сегодня компания собирается организовать праздник. Для этого необходимо разделить всех _n_ сотрудников на несколько групп: каждый человек должен относиться ровно к одной группе. Более того, в каждой группе не должно быть таких двух сотрудников _A_ и _B_, что _A_ является начальником _B_.

Ваша задача – найти наименьшее возможное количество таких групп.

#### Входные данные

Первая строка содержит целое число _n_ (1 ≤ _n_ ≤ 2000) – количество сотрудников.

Следующие _n_ строк содержат целые числа pi (1 ≤ pi ≤ _n_ или pi= -1). Каждое pi обозначает непосредственного руководителя _i_-го сотрудника. Если pi равно -1, то _i_-ый сотрудник не имеет непосредственного руководителя.

Гарантируется, что никакой сотрудник не является своим собственным непосредственным руководителем (pi ≠ _i_). Также гарантируется, что структура компании не содержит циклов.

#### Выходные данные

Выведите единственное целое число – минимальное количество групп, на которые можно разделить всех сотрудников.

---

## Решение задачи

В компании работает несколько сотрудников, каждый из которых имеет либо одного непосредственного руководителя, либо не имеет руководителя вовсе. Руководитель обозначается как другой сотрудник компании. 

Таким образом, отношения между сотрудниками образуют **иерархическую структуру** – дерево или лес деревьев (если есть несколько корней, то есть сотрудников без начальника).

![Image](/Holiday/img/1.png)
Сотрудник считается начальником другого, если он напрямую руководит этим сотрудником или если он является начальником кого-то из вышестоящих в этой цепочке.

Для решения задачи нужно выяснить, **насколько глубокой может быть иерархия**. Это связано с тем, что в одном уровне иерархии (например, все сотрудники на одинаковом "этаже" иерархического дерева) начальники и подчинённые не пересекаются. 

Следовательно, если самая длинная цепочка подчинённости (от самого нижнего сотрудника до вершины) состоит, скажем, из 4 человек, то потребуется как минимум 4 группы – по одной на каждый уровень иерархии.

Иными словами, минимальное количество групп равно высоте самого глубокого подчинённого дерева в организации.


---

## Описание решения задачи на C#

[Программа](/Holiday/HolidayCSharp/Program.cs) начинается с того, что считывает число сотрудников – это просто целое число (`n`), задающее количество работников в компании. Затем считывается список из `n` чисел. Каждое из этих чисел указывает на непосредственного руководителя соответствующего сотрудника. Если указано `-1`, это означает, что у данного сотрудника нет начальника, и он находится на вершине своей иерархической ветви.

Для хранения этой информации создаётся массив `p`. В этом массиве под индексом `i` хранится значение `p[i]`, соответствующее начальнику `i`-го сотрудника. Индексация начинается с единицы, чтобы номера сотрудников удобно совпадали с индексами массива (например, `p[1]`, `p[2]` и т.д.).

Затем начинается основной этап – перебор всех сотрудников. Цель этого этапа – выяснить, какой максимальной глубины достигает структура подчинённости. То есть, сколько максимум уровней «сотрудник → начальник → начальник начальника → ...» может быть в цепочке для какого-либо сотрудника.

Для каждого сотрудника программа начинает подниматься вверх по иерархии: сначала берётся его начальник (`t = p[i]`), затем начальник этого начальника (`t = p[t]`) и так далее, пока не дойдёт до сотрудника, у которого нет руководителя (`t == -1`). При этом на каждом шаге подсчитывается длина такой цепочки с помощью счётчика (`c++`), который изначально равен единице (`int c = 1`), так как сам сотрудник уже считается.

После прохождения этой цепочки программа сравнивает её длину `c` с текущим максимумом `ans` и при необходимости обновляет его через `Math.Max(ans, c)`. Таким образом, после того как программа проверит всех сотрудников, она будет знать наибольшую возможную глубину иерархии в компании.

Этот максимум (`ans`) и есть ответ на задачу. Он показывает, на сколько независимых групп нужно разделить сотрудников, чтобы ни один сотрудник не оказался в одной группе с кем-либо из своих начальников. 

## Описание решения задачи на F#

Решение задачи [на F#](Holiday/HolidayFSharp/Program.fs) устроено по тому же принципу, что и на C#. 
Программа на F# начинается с чтения количества сотрудников `n`. Следующей строкой считывается список из `n` чисел, где каждое число указывает на непосредственного начальника соответствующего сотрудника. Если в списке указано `-1`, это означает, что у сотрудника нет начальника.

Считанный список преобразуется с помощью `Array.map int` и далее превращается в список (`input : int list`). К этому списку добавляется фиктивный элемент в начало (`0 :: input`), чтобы индекс сотрудников удобно совпадал с индексами списка (`pList`).

Основная логика построена на рекурсивной функции `depth`, которая вычисляет глубину подчинённости для конкретного сотрудника. Функция принимает список начальников `p` и индекс сотрудника `i`. Если `p[i] = -1`, то глубина равна единице – сотрудник находится на вершине своей иерархии. В противном случае вызывается рекурсивный расчёт глубины для его начальника: `1 + depth p boss`. Таким образом, `depth` возвращает длину пути от текущего сотрудника до самого верхнего начальника.

Далее программа создаёт список всех сотрудников от 1 до `n` с помощью `List.init n (fun i -> i + 1)`. Для каждого из них вычисляется глубина (`List.map (depth pList)`), и в конце берётся максимальное значение среди всех глубин (`List.max`). Это и есть ответ на задачу.

## Описание решения задачи на Prolog

Решение задачи в [Prolog](/Holiday/HolidayProlog/Holiday.pl) начинается с того, что программа ожидает два ввода: количество сотрудников (`N`) и список их начальников (`PList`). Этот список содержит по одному числу для каждого сотрудника – номер его непосредственного начальника. Если указано `-1`, значит сотрудник не имеет начальника и находится на вершине своей иерархии.

Для определения глубины подчинённости каждого сотрудника используется рекурсивный предикат `depth`. Он принимает список начальников `PList`, номер сотрудника `I` и возвращает глубину `D`. Если сотрудник не имеет начальника, то глубина равна единице:

`depth(PList, I, 1) :- get_at(I, PList, -1).`

Если начальник есть, программа сначала находит его (предикат `get_at`), затем рекурсивно определяет его глубину, и увеличивает результат на единицу:

`depth(PList, I, D) :- get_at(I, PList, Boss), depth(PList, Boss, D1), D is D1 + 1.`

Здесь `get_at` – это вспомогательный предикат для получения элемента списка по индексу (счёт начинается с 1). Он реализован через рекурсивное смещение по списку: уменьшая индекс на каждом шаге, пока не дойдём до нужного элемента.

После этого используется предикат `all_depths`, чтобы вычислить глубину для **всех** сотрудников – от `n` до `1`. Он рекурсивно вызывает `depth` и собирает список всех глубин (`Depths`):

`all_depths(PList, N, [D | Rest]) :- depth(PList, N, D), N1 is N - 1, all_depths(PList, N1, Rest).`

Когда список глубин готов, программа применяет предикат `max_in_list`, чтобы найти максимальное значение в этом списке. Это значение и есть ответ на задачу - сколько независимых групп потребуется для организации праздника, чтобы ни один начальник не оказался в одной группе со своим подчинённым.

---

## Тест-кейсы


### Тест-кейс 1: Минимальный случай

Входные данные: 
```
1
-1
```

**Ожидаемый результат:**

Выходные данные:
```
1
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы | Время работы     | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `1`       |     0.001 сек    |        0.02 МБ        |
|   F#     |        `1`       |     0.021 сек    |        0.041 МБ       |
|  Prolog  |        `1`       |     0.001 сек    |        0.01 МБ        |

Результат тестирования: **ПРОЙДЕНО**.

##
### Тест-кейс 2: Одна цепочка

Входные данные: 
```
3
-1 1 2
```

**Ожидаемый результат:**

Выходные данные:
```
3
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `3`       |     0.001 сек    |        0.02 МБ        |
|   F#     |        `3`       |     0.023 сек    |        0.041 МБ       |
|  Prolog  |        `3`       |     0.001 сек    |        0.01 МБ        |

Результат тестирования: **ПРОЙДЕНО**.

##
### Тест-кейс 3: Один начальник

Входные данные: 
```
4
-1 1 1 1
```

**Ожидаемый результат:**

Выходные данные:
```
2
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `2`       |     0.001 сек    |        0.02 МБ        |
|   F#     |        `2`       |     0.033 сек    |        0.041 МБ       |
|  Prolog  |        `2`       |     0.001 сек    |        0.01 МБ        |

Результат тестирования: **ПРОЙДЕНО**.


##
### Тест-кейс 4: Два независимых дерева

Входные данные: 
```
6
-1 1 2 -1 4 5
```

**Ожидаемый результат:**

Выходные данные:
```
3
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `3`       |     0.002 сек    |        0.01 МБ        |
|   F#     |        `3`       |     0.032 сек    |        0.041 МБ       |
|  Prolog  |        `3`       |     0.001 сек    |        0.01 МБ        |

Результат тестирования: **ПРОЙДЕНО**.

##
### Тест-кейс 5: Все независимы

Входные данные: 
```
5
-1 -1 -1 -1 -1
```

**Ожидаемый результат:**

Выходные данные:
```
1
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `1`       |     0.001 сек    |        0.02 МБ        |
|   F#     |        `1`       |     0.028 сек    |        0.041 МБ       |
|  Prolog  |        `1`       |     0.001 сек    |        0.01 МБ        |

Результат тестирования: **ПРОЙДЕНО**.

##
### Тест-кейс 6: Сбалансированное дерево

Входные данные: 
```
7
-1 1 1 2 2 3 3
```

**Ожидаемый результат:**

Выходные данные:
```
3
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `3`       |     0.001 сек    |        0.02 МБ        |
|   F#     |        `3`       |     0.022 сек    |        0.041 МБ       |
|  Prolog  |        `3`       |     0.001 сек    |        0.01 МБ        |

Результат тестирования: **ПРОЙДЕНО**.

##
### Тест-кейс 7: Смешанная глубина

Входные данные: 
```
8
-1 1 1 2 3 -1 6 6
```

**Ожидаемый результат:**

Выходные данные:
```
3
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `3`       |     0.001 сек    |        0.11 МБ        |
|   F#     |        `3`       |     0.031 сек    |        0.041 МБ       |
|  Prolog  |        `3`       |     0.001 сек    |        0.01 МБ        |

Результат тестирования: **ПРОЙДЕНО**.

##
### Тест-кейс 8: Длинная цепочка из 10 человек

Входные данные: 
```
10
-1 1 2 3 4 5 6 7 8 9
```

**Ожидаемый результат:**

Выходные данные:
```
10
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `10`      |     0.001 сек    |        0.01 МБ        |
|   F#     |        `10`      |     0.030 сек    |        0.042 МБ       |
|  Prolog  |        `10`      |     0.001 сек    |        0.01 МБ        |

Результат тестирования: **ПРОЙДЕНО**.


##
### Тест-кейс 9: Случай на 15 сотрудников, с разными начальниками

Входные данные: 
```
15
-1 -1 1 1 2 2 3 3 4 5 5 6 6 7 7
```

**Ожидаемый результат:**

Выходные данные:
```
4
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `4`       |     0.001 сек    |        0.02 МБ        |
|   F#     |        `4`       |     0.021 сек    |        0.042 МБ       |
|  Prolog  |        `4`       |     0.001 сек    |        0.01 МБ        |

Результат тестирования: **ПРОЙДЕНО**.


##
### Тест-кейс 10: Случай на 20 сотрудников, с разными начальниками

Входные данные: 
```
20
-1 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 9 10 11 12
```

**Ожидаемый результат:**

Выходные данные:
```
5
```
Ограничение по времени на тест: 2 секунды

Ограничение по памяти на тест: 256 мегабайт

Полученный результат:
| Язык     | Результат работы |   Время работы   | Использованная память |
| -------- | ---------------- | ---------------- | --------------------- |
|   C#     |        `5`       |     0.001 сек    |        0.11 МБ        |
|   F#     |        `5`       |     0.027 сек    |        0.043 МБ       |
|  Prolog  |        `5`       |     0.001 сек    |        0.01 МБ        |

Результат тестирования: **ПРОЙДЕНО**.

### Все тест-кейсы успнешно пройдены.